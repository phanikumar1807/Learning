package april22;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ExcelDuplicateRemover {

    private static final String FILE_PATH = "C:\\Users\\inahp\\Desktop\\demo.xlsx"; // Replace with your file path
    private static final String SHEET_NAME = "Active Jiras"; // Replace with your sheet name
    private static final String UNIQUE_SHEET_NAME = "Scrubbed active Jiras"; // Name for the new sheet

    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream(FILE_PATH);
            Workbook workbook = new XSSFWorkbook(fis);
            Sheet sheet = workbook.getSheet(SHEET_NAME);

            if (sheet == null) {
                System.out.println("Sheet '" + SHEET_NAME + "' not found in the workbook.");
                return;
            }

            // Find column indices for "issue_key" and "Issue_link"
            int issueKeyColIndex = -1;
            int issueLinkColIndex = -1;

            Row headerRow = sheet.getRow(0); // Assuming header is in the first row (row 0)
            if (headerRow != null) {
                for (Cell cell : headerRow) {
                    String cellValue = cell.getStringCellValue();
                    if ("issue Key".equalsIgnoreCase(cellValue)) {
                        issueKeyColIndex = cell.getColumnIndex();
                    } else if ("Issue_Link".equalsIgnoreCase(cellValue)) {
                        issueLinkColIndex = cell.getColumnIndex();
                    }
                }
            }

            if (issueKeyColIndex == -1 || issueLinkColIndex == -1) {
                System.out.println("Could not find 'issue_key' or 'Issue_link' columns in the header.");
                return;
            }

            Set<String> uniqueCombinations = new HashSet<>();
            List<Row> uniqueRows = new ArrayList<>();

            // Iterate over rows, starting from the second row (skipping header)
            Iterator<Row> rowIterator = sheet.iterator();
            if (rowIterator.hasNext()) {
                uniqueRows.add(rowIterator.next()); // Add header row to uniqueRows
            }

            while (rowIterator.hasNext()) {
                Row currentRow = rowIterator.next();
                Cell issueKeyCell = currentRow.getCell(issueKeyColIndex);
                Cell issueLinkCell = currentRow.getCell(issueLinkColIndex);

                String issueKey = getCellValueAsString(issueKeyCell);
                String issueLink = getCellValueAsString(issueLinkCell);

                String combinedKey = issueKey + "_" + issueLink; // Create a unique combination key

                if (!uniqueCombinations.contains(combinedKey)) {
                    uniqueCombinations.add(combinedKey);
                    uniqueRows.add(currentRow); // Add the entire row if it's unique
                }
            }
            fis.close();

            // Create a new sheet for unique data
            Sheet uniqueSheet = workbook.createSheet(UNIQUE_SHEET_NAME);

            // Copy unique rows to the new sheet
            for (int i = 0; i < uniqueRows.size(); i++) {
                Row sourceRow = uniqueRows.get(i);
                Row newRow = uniqueSheet.createRow(i);
                for (int j = 0; j < sourceRow.getLastCellNum(); j++) {
                    Cell sourceCell = sourceRow.getCell(j);
                    if (sourceCell != null) {
                        Cell newCell = newRow.createCell(j, sourceCell.getCellType());
                        copyCellValue(sourceCell, newCell);
                    }
                }
            }

            // Save the workbook
            FileOutputStream fos = new FileOutputStream(FILE_PATH);
            workbook.write(fos);
            workbook.close();
            fos.close();

            System.out.println("Duplicate rows removed and unique data saved to sheet '" + UNIQUE_SHEET_NAME + "' in " + FILE_PATH);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Helper method to get cell value as String, handling different cell types
    private static String getCellValueAsString(Cell cell) {
        if (cell == null) {
            return "";
        }
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                // Handle numeric cells, including dates
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue().toString(); // Or format as needed
                } else {
                    return String.valueOf(cell.getNumericCellValue());
                }
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            case FORMULA:
                // Evaluate formulas if needed, otherwise return the formula string
                return cell.getCellFormula();
            case BLANK:
                return "";
            default:
                return "";
        }
    }

    // Helper method to copy cell content and style
    private static void copyCellValue(Cell oldCell, Cell newCell) {
        if (oldCell == null) {
            return;
        }

        // Copy cell value
        switch (oldCell.getCellType()) {
            case STRING:
                newCell.setCellValue(oldCell.getStringCellValue());
                break;
            case NUMERIC:
                newCell.setCellValue(oldCell.getNumericCellValue());
                break;
            case BOOLEAN:
                newCell.setCellValue(oldCell.getBooleanCellValue());
                break;
            case FORMULA:
                newCell.setCellFormula(oldCell.getCellFormula());
                break;
            case ERROR:
                newCell.setCellErrorValue(oldCell.getErrorCellValue());
                break;
            case BLANK:
                // Do nothing for blank cells
                break;
		case _NONE:
			break;
		default:
			break;
        }

        // Copy cell style (optional, but good for preserving formatting)
        CellStyle newCellStyle = oldCell.getSheet().getWorkbook().createCellStyle();
        newCellStyle.cloneStyleFrom(oldCell.getCellStyle());
        newCell.setCellStyle(newCellStyle);
    }
}
